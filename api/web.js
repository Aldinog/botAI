const { fetchHarga } = require('../src/utils/harga');
const { analyzeStock } = require('../src/utils/analisys');
const { analyzeWithGemini } = require('../src/utils/gemini');
const {
    fetchHistorical,
    analyzeProxyBrokerActivity,
    formatProxyBrokerActivity
} = require('../src/utils/goapi');
const { computeIndicators, formatIndicatorsForPrompt } = require('../src/utils/indicators');
// Remove static require
// const { marked } = require('marked');

// Dynamic import helper
let marked;
async function loadMarked() {
    if (!marked) marked = (await import("marked")).marked;
    return marked;
}

// Helper to remove HTML tags or markdown if needed for simple display, 
// but we might want to keep some specific formatting for the web.
// For now, we'll return raw text or HTML as generated by the utils.

module.exports = async (req, res) => {
    // Enable CORS
    res.setHeader('Access-Control-Allow-Credentials', true);
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS,PATCH,DELETE,POST,PUT');
    res.setHeader(
        'Access-Control-Allow-Headers',
        'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version'
    );

    if (req.method === 'OPTIONS') {
        res.status(200).end();
        return;
    }

    if (req.method !== 'POST') {
        return res.status(405).json({ error: 'Method Not Allowed' });
    }

    const { action, symbol } = req.body;

    if (!symbol) {
        return res.status(400).json({ error: 'Symbol is required' });
    }

    try {
        let result = '';

        switch (action) {
            case 'price':
                result = await fetchHarga(symbol);
                break;

            case 'indicators':
                const analysis = await analyzeStock(symbol);
                result = analysis.text || analysis.error;
                break;

            case 'analysis':
                // Replicating /analisa logic
                const candles = await fetchHistorical(symbol, { limit: 50 });
                if (!candles || candles.length === 0) {
                    result = `❌ Data ${symbol} tidak tersedia.`;
                } else {
                    const indicators = computeIndicators(candles);
                    const prompt = formatIndicatorsForPrompt(symbol, indicators);
                    result = await analyzeWithGemini(prompt);
                }
                break;

            case 'proxy':
                // Replicating /proxy logic
                const candlesProxy = await fetchHistorical(symbol, { limit: 120 });
                const activity = analyzeProxyBrokerActivity(candlesProxy);
                result = formatProxyBrokerActivity(symbol, activity);
                break;

            case 'signal':
                const { generateSignal } = await import('../src/utils/signal.js');
                result = await generateSignal(symbol);
                break;

            case 'review':
                const { generateReview } = await import('../src/utils/review.js');
                const { entry, sl, mode } = req.body; // mode = BUY/SELL
                // Check required params
                if (!entry || !mode) {
                    result = "❌ Data entry dan action (BUY/SELL) wajib diisi.";
                } else {
                    result = await generateReview(mode, symbol, entry, sl);
                }
                break;

            default:
                return res.status(400).json({ error: 'Invalid action' });
        }

        // Convert Markdown to HTML for web display if it's not already HTML
        // fetchHarga returns strings with emojis, some utils return HTML, some Markdown.
        // Ideally we treat everything as HTML or convert MD to HTML.
        // Simple heuristic: if it contains <b> or <br>, assume HTML, else Markdown.
        const isHtml = /<[a-z][\s\S]*>/i.test(result);
        // Even if it is HTML, we might want to run it through marked if it has mixed content? 
        // Actually, existing bot output is mixed.
        // Let's standardise on sending JSON with a 'html' field.

        let htmlOutput = result;
        if (!isHtml) {
            const markedFn = await loadMarked();
            htmlOutput = markedFn(result, { breaks: true });
        }
        // Force newlines to <br> if not handled by marked (e.g. plain text with \n)
        // If marked handled it, it should have inserted <br> for \n
        if (!htmlOutput.includes('<p>') && !htmlOutput.includes('<br>')) {
            htmlOutput = htmlOutput.replace(/\n/g, '<br>');
        }

        res.status(200).json({
            success: true,
            data: htmlOutput
        });

    } catch (error) {
        console.error('Web Context Error:', error);
        res.status(500).json({ error: 'Internal Server Error: ' + error.message });
    }
};
