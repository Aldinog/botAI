const { fetchHarga } = require('../src/utils/harga');
const { analyzeStock } = require('../src/utils/analisys');
const { analyzeWithAI } = require('../src/utils/ai');
const {
    fetchHistorical,
    analyzeProxyBrokerActivity,
    formatProxyBrokerActivity,
    fetchFundamentals,
    formatFundamentals,
    fetchProfile,
    formatProfile
} = require('../src/utils/yahoofinance');
const { computeIndicators, formatIndicatorsForPrompt } = require('../src/utils/indicators');
const { calculateAvg, formatAvgReport } = require('../src/utils/avg');
const { markdownToTelegramHTML } = require('../src/utils/telegram');
const jwt = require('jsonwebtoken');
const { supabase } = require('../src/utils/supabase');
const axios = require('axios');
// Remove static require
// const { marked } = require('marked');

// Dynamic import helper
let marked;
async function loadMarked() {
    if (!marked) marked = (await import("marked")).marked;
    return marked;
}

// Helper to remove HTML tags or markdown if needed for simple display, 
// but we might want to keep some specific formatting for the web.
// For now, we'll return raw text or HTML as generated by the utils.

module.exports = async (req, res) => {
    // Enable CORS
    res.setHeader('Access-Control-Allow-Credentials', true);
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS,PATCH,DELETE,POST,PUT');
    res.setHeader(
        'Access-Control-Allow-Headers',
        'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version'
    );

    if (req.method === 'OPTIONS') {
        res.status(200).end();
        return;
    }

    if (req.method !== 'POST') {
        return res.status(405).json({ error: 'Method Not Allowed' });
    }

    const { action, symbol } = req.body;
    let activeTheme = 'default';

    // --- Authentication Middleware ---
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({ error: 'Unauthorized: Missing token' });
    }

    const token = authHeader.split(' ')[1];

    try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET || 'fallback-secret-aston');

        // Check session in DB
        const { data: session, error: sessionError } = await supabase
            .from('sessions')
            .select('user_id, users(*)')
            .eq('token', token)
            .single();

        if (sessionError || !session || !session.users.is_active) {
            return res.status(401).json({ error: 'Unauthorized: Invalid or inactive session' });
        }

        const user = session.users;
        const isAdmin = user.telegram_user_id.toString() === (process.env.ADMIN_ID || '');

        // --- Maintenance & Theme Logic ---
        const { data: appData } = await supabase
            .from('app_settings')
            .select('key, value')
            .in('key', ['maintenance_mode', 'maintenance_end_time', 'active_theme']);

        const settingsMap = {};
        if (appData) {
            appData.forEach(item => settingsMap[item.key] = item.value);
        }

        let isMaintenance = settingsMap['maintenance_mode'] || false;
        let maintenanceEndTime = settingsMap['maintenance_end_time'];
        activeTheme = settingsMap['active_theme'] || 'default';

        // Auto-Disable Logic
        if (isMaintenance && maintenanceEndTime) {
            const now = new Date();
            const end = new Date(maintenanceEndTime);
            if (now >= end) {
                // Auto Turn Off
                await supabase.from('app_settings').upsert([
                    { key: 'maintenance_mode', value: false },
                    { key: 'maintenance_end_time', value: null }
                ]);
                isMaintenance = false;
                maintenanceEndTime = null;
                console.log('Maintenance Mode Auto-Disabled (Time Reached)');
            }
        }

        // If maintenance is ON and user is NOT admin, block all EXCEPT public/helper actions if any
        if (isMaintenance && !isAdmin) {
            return res.status(503).json({
                error: 'Mohon maaf APP masih Maintenance',
                code: 'MAINTENANCE_MODE',
                end_time: maintenanceEndTime // Return time for countdown
            });
        }

        // Check expiry (3-day rule)
        if (new Date(user.expires_at) < new Date()) {
            return res.status(403).json({ error: 'Access expired. Please re-register.' });
        }

        // --- Membership Check (CRITICAL) ---
        // ... (existing membership check logic)
        const groupIds = process.env.ALLOWED_GROUP_IDS ? process.env.ALLOWED_GROUP_IDS.split(',') : [];
        const primaryGroupId = groupIds[0];

        try {
            const memberCheck = await axios.get(`https://api.telegram.org/bot${process.env.TELEGRAM_TOKEN}/getChatMember`, {
                params: { chat_id: primaryGroupId, user_id: user.telegram_user_id }
            });
            const status = memberCheck.data.result.status;
            if (!['creator', 'administrator', 'member'].includes(status)) {
                return res.status(403).json({ error: 'Jika sudah join silahkan buka ulang App' });
            }
        } catch (e) {
            console.error('Group check failed in middleware:', e.message);
            return res.status(500).json({ error: 'Security check failed' });
        }

        // --- Admin Specific Actions ---
        if (action === 'toggle-maintenance') {
            if (!isAdmin) return res.status(403).json({ error: 'Akses ditolak: Admin only' });

            const { endTime } = req.body; // Expect ISO string or null
            const newState = !isMaintenance;

            // Prepare updates
            const updates = [
                { key: 'maintenance_mode', value: newState }
            ];

            if (newState && endTime) {
                updates.push({ key: 'maintenance_end_time', value: endTime });
            } else if (!newState) {
                // Clear time if turning off
                updates.push({ key: 'maintenance_end_time', value: null });
            }

            await supabase.from('app_settings').upsert(updates);

            // Return the new end_time so frontend can update immediately
            const returnedEndTime = newState ? endTime : null;
            return res.status(200).json({
                success: true,
                is_maintenance: newState,
                maintenance_end_time: returnedEndTime
            });
        }

        if (action === 'watchlist/list') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            const { data, error } = await supabase.from('monitor_symbols').select('*').order('symbol');
            if (error) return res.status(400).json({ error: error.message });
            return res.status(200).json({ success: true, data });
        }

        if (action === 'watchlist/add') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            const { symbol: newSym } = req.body;
            if (!newSym) return res.status(400).json({ error: 'Symbol required' });
            const formattedSym = newSym.toUpperCase().endsWith('.JK') ? newSym.toUpperCase() : `${newSym.toUpperCase()}.JK`;
            const { error } = await supabase.from('monitor_symbols').insert([{ symbol: formattedSym, is_active: true }]);
            if (error) return res.status(400).json({ error: error.message });
            return res.status(200).json({ success: true });
        }

        if (action === 'watchlist/delete') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            const { symbol: targetSym } = req.body;
            await supabase.from('monitor_symbols').delete().eq('symbol', targetSym);
            return res.status(200).json({ success: true });
        }

        if (action === 'watchlist/toggle') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            const { symbol: targetSym, is_active } = req.body;
            await supabase.from('monitor_symbols').update({ is_active }).eq('symbol', targetSym);
            return res.status(200).json({ success: true });
        }

        if (action === 'admin/force-scan') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            // For architecture simplicity, we'll try to trigger the internal logic
            const scanner = require('./cron/scanner');
            const mockReq = { body: {} };
            const mockRes = {
                status: (code) => ({ json: (data) => { console.log('Mock Scanner Finish:', data); } })
            };
            scanner(mockReq, mockRes);
            return res.status(200).json({ success: true, message: 'Scanner triggered in background' });
        }

        if (action === 'admin/update-theme') {
            if (!isAdmin) return res.status(403).json({ error: 'Admin only' });
            const { theme } = req.body;
            await supabase.from('app_settings').upsert({ key: 'active_theme', value: theme });
            return res.status(200).json({ success: true, theme });
        }

        // Log MiniApp Usage
        const username = user.telegram_username || `ID:${user.telegram_user_id}`;
        if (action) {
            console.log(`${username} menggunakan miniapp ${action}`);
        }

    } catch (err) {
        return res.status(401).json({ error: 'Unauthorized: Invalid token' });
    }
    // --- End Authentication Middleware ---


    if (!symbol) {
        return res.status(400).json({ error: 'Symbol is required' });
    }


    try {
        let result = '';

        switch (action) {
            case 'price': // Replaced by Profile
            case 'profile':
                const profileData = await fetchProfile(symbol);
                result = formatProfile(profileData);
                break;

            case 'fundamental':
                const fundData = await fetchFundamentals(symbol);
                result = formatFundamentals(fundData);
                break;

            case 'indicators':
                const analysis = await analyzeStock(symbol);
                result = analysis.text || analysis.error;
                break;

            case 'analysis':
                // Replicating /analisa logic
                const candles = await fetchHistorical(symbol, { limit: 50 });
                if (!candles || candles.length === 0) {
                    result = `❌ Data ${symbol} tidak tersedia.`;
                } else {
                    const indicators = computeIndicators(candles);
                    const prompt = formatIndicatorsForPrompt(symbol, indicators);
                    result = await analyzeWithAI(prompt);
                }
                break;

            case 'proxy':
                // Replicating /proxy logic
                const candlesProxy = await fetchHistorical(symbol, { limit: 120 });
                const activity = analyzeProxyBrokerActivity(candlesProxy);
                result = formatProxyBrokerActivity(symbol, activity);
                break;

            case 'chart':
                // Dynamic import to keep init fast
                const { getChartData } = require('../src/utils/charting');
                const interval = req.body.interval || '1d';
                const limit = req.body.limit || 300;
                console.log(`[API] Processing chart request for ${symbol} interval ${interval} limit ${limit}`);

                try {
                    const chartData = await getChartData(symbol, interval, limit);
                    console.log(`[API] Returning chart data: ${chartData.candles.length} candles, ${chartData.markers.length} markers`);

                    // Directly return JSON, bypass HTML formatting logic
                    return res.status(200).json({
                        success: true,
                        data: chartData
                    });
                } catch (error) {
                    console.error(`[API] Chart Error:`, error);
                    return res.status(500).json({ success: false, error: error.message });
                }

            case 'signal':
                const { generateSignal } = await import('../src/utils/signal.js');
                result = await generateSignal(symbol);
                break;

            case 'review':
                const { generateReview } = await import('../src/utils/review.js');
                const { entry, sl, mode } = req.body;
                if (!entry || !mode) {
                    result = "❌ Data entry dan action (BUY/SELL) wajib diisi.";
                } else {
                    result = await generateReview(mode, symbol, entry, sl);
                }
                break;

            case 'avg':
                const { p1, l1, p2, targetAvg, l2Input, slPercent, tpPercent, feeBuy, feeSell } = req.body;
                if (!p1 || !l1) {
                    result = "❌ Data harga beli lama dan jumlah lot wajib diisi.";
                } else {
                    // Try to fetch current price for simulation if P2 is not manually provided
                    let finalP2 = p2;
                    let currentPrice = null;
                    try {
                        const priceData = await fetchHarga(symbol);
                        // Extract number from and result like "BUVA | 123 | +1%"
                        // fetchHarga returns a string. We need a numerical price for calculations.
                        // However, fetchHarga output is formatted for the bot.
                        // Let's use fetchHistorical or similar for a clean number if possible.
                        const candles = await fetchHistorical(symbol, { limit: 1 });
                        if (candles && candles.length > 0) {
                            currentPrice = candles[0].close;
                            if (!finalP2) finalP2 = currentPrice;
                        }
                    } catch (e) {
                        console.error("Price fetch failed for avg calculator:", e);
                    }

                    if (!finalP2) {
                        return res.json({ success: false, error: 'Harga beli baru (P2) tidak ditemukan dan tidak diisi secara manual.' });
                    } else {
                        const avgData = calculateAvg({
                            symbol,
                            p1: Number(p1),
                            l1: Number(l1),
                            p2: Number(finalP2),
                            targetAvg: targetAvg ? Number(targetAvg) : null,
                            l2Input: l2Input ? Number(l2Input) : null,
                            currentPrice: currentPrice,
                            slPercent,
                            tpPercent,
                            feeBuy,
                            feeSell
                        });
                        const reportHtml = await markdownToTelegramHTML(formatAvgReport(avgData));
                        return res.json({
                            success: true,
                            data: reportHtml,
                            raw: avgData, // Send raw data for chart visualization
                            active_theme: (await supabase.from('user_themes').select('active_theme').eq('session_token', sessionToken).maybeSingle()).data?.active_theme
                        });
                    }
                }
                break;

            default:
                return res.status(400).json({ error: 'Invalid action' });
        }

        // Convert Markdown to HTML for web display if it's not already HTML
        // fetchHarga returns strings with emojis, some utils return HTML, some Markdown.
        // Ideally we treat everything as HTML or convert MD to HTML.
        // Simple heuristic: if it contains <b> or <br>, assume HTML, else Markdown.
        const isHtml = /<[a-z][\s\S]*>/i.test(result);
        // Even if it is HTML, we might want to run it through marked if it has mixed content? 
        // Actually, existing bot output is mixed.
        // Let's standardise on sending JSON with a 'html' field.

        let htmlOutput = result;
        if (!isHtml) {
            const markedFn = await loadMarked();
            htmlOutput = markedFn(result, { breaks: true });
        }
        // Force newlines to <br> if not handled by marked (e.g. plain text with \n)
        // If marked handled it, it should have inserted <br> for \n
        if (!htmlOutput.includes('<p>') && !htmlOutput.includes('<br>')) {
            htmlOutput = htmlOutput.replace(/\n/g, '<br>');
        }

        res.status(200).json({
            success: true,
            data: htmlOutput,
            active_theme: activeTheme // Added for real-time theme sync
        });

    } catch (error) {
        console.error('Web Context Error:', error);
        res.status(500).json({
            error: error.message || 'AI Overload, Cobalagi beberapa saat',
            details: error.message || error,
            hint: 'Pastikan OPENROUTER_API_KEY sudah terpasang di Vercel Dashboard.'
        });
    }
};
