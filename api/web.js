const { fetchHarga } = require('../src/utils/harga');
const { analyzeStock } = require('../src/utils/analisys');
const { analyzeWithAI } = require('../src/utils/ai');
const {
    fetchHistorical,
    analyzeProxyBrokerActivity,
    formatProxyBrokerActivity,
    fetchFundamentals,
    formatFundamentals
} = require('../src/utils/yahoofinance');
const { computeIndicators, formatIndicatorsForPrompt } = require('../src/utils/indicators');
const jwt = require('jsonwebtoken');
const { supabase } = require('../src/utils/supabase');
const axios = require('axios');
// Remove static require
// const { marked } = require('marked');

// Dynamic import helper
let marked;
async function loadMarked() {
    if (!marked) marked = (await import("marked")).marked;
    return marked;
}

// Helper to remove HTML tags or markdown if needed for simple display, 
// but we might want to keep some specific formatting for the web.
// For now, we'll return raw text or HTML as generated by the utils.

module.exports = async (req, res) => {
    // Enable CORS
    res.setHeader('Access-Control-Allow-Credentials', true);
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS,PATCH,DELETE,POST,PUT');
    res.setHeader(
        'Access-Control-Allow-Headers',
        'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version'
    );

    if (req.method === 'OPTIONS') {
        res.status(200).end();
        return;
    }

    if (req.method !== 'POST') {
        return res.status(405).json({ error: 'Method Not Allowed' });
    }

    const { action, symbol } = req.body;

    // --- Authentication Middleware ---
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({ error: 'Unauthorized: Missing token' });
    }

    const token = authHeader.split(' ')[1];

    try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET || 'fallback-secret-aston');

        // Check session in DB
        const { data: session, error: sessionError } = await supabase
            .from('sessions')
            .select('user_id, users(*)')
            .eq('token', token)
            .single();

        if (sessionError || !session || !session.users.is_active) {
            return res.status(401).json({ error: 'Unauthorized: Invalid or inactive session' });
        }

        const user = session.users;

        // Check expiry (3-day rule)
        if (new Date(user.expires_at) < new Date()) {
            return res.status(403).json({ error: 'Access expired. Please re-register.' });
        }

        // --- Membership Check (CRITICAL) ---
        // To avoid "register then leave" exploit, we verify membership
        const groupIds = process.env.ALLOWED_GROUP_IDS ? process.env.ALLOWED_GROUP_IDS.split(',') : [];
        const primaryGroupId = groupIds[0];

        try {
            const memberCheck = await axios.get(`https://api.telegram.org/bot${process.env.TELEGRAM_TOKEN}/getChatMember`, {
                params: { chat_id: primaryGroupId, user_id: user.telegram_user_id }
            });
            const status = memberCheck.data.result.status;
            if (!['creator', 'administrator', 'member'].includes(status)) {
                // If they left, deactivate or just block
                return res.status(403).json({ error: 'Silahkan Join Aston Group untuk melanjutkan' });
            }
        } catch (e) {
            console.error('Group check failed in middleware:', e.message);
            // If API fails, we might fallback to allowing if the token is recent, 
            // but for maximum security we block.
            return res.status(500).json({ error: 'Security check failed' });
        }

        // Log MiniApp Usage
        const username = user.telegram_username || `ID:${user.telegram_user_id}`;
        if (action) {
            console.log(`${username} menggunakan miniapp ${action}`);
        }

    } catch (err) {
        return res.status(401).json({ error: 'Unauthorized: Invalid token' });
    }
    // --- End Authentication Middleware ---


    if (!symbol) {
        return res.status(400).json({ error: 'Symbol is required' });
    }


    try {
        let result = '';

        switch (action) {
            case 'price':
                result = await fetchHarga(symbol);
                break;

            case 'indicators':
                const analysis = await analyzeStock(symbol);
                result = analysis.text || analysis.error;
                break;

            case 'analysis':
                // Replicating /analisa logic
                const candles = await fetchHistorical(symbol, { limit: 50 });
                if (!candles || candles.length === 0) {
                    result = `❌ Data ${symbol} tidak tersedia.`;
                } else {
                    const indicators = computeIndicators(candles);
                    const prompt = formatIndicatorsForPrompt(symbol, indicators);
                    result = await analyzeWithAI(prompt);
                }
                break;

            case 'proxy':
                // Replicating /proxy logic
                const candlesProxy = await fetchHistorical(symbol, { limit: 120 });
                const activity = analyzeProxyBrokerActivity(candlesProxy);
                result = formatProxyBrokerActivity(symbol, activity);
                break;

            case 'fundamental':
            case 'profile':
                const fundData = await fetchFundamentals(symbol);
                result = formatFundamentals(fundData);
                break;

            case 'chart':
                // Dynamic import to keep init fast
                const { getChartData } = require('../src/utils/charting');
                const interval = req.body.interval || '1d';
                console.log(`[API] Processing chart request for ${symbol} interval ${interval}`);

                try {
                    const chartData = await getChartData(symbol, interval);
                    console.log(`[API] Returning chart data: ${chartData.candles.length} candles, ${chartData.markers.length} markers`);

                    // Directly return JSON, bypass HTML formatting logic
                    return res.status(200).json({
                        success: true,
                        data: chartData
                    });
                } catch (error) {
                    console.error(`[API] Chart Error:`, error);
                    return res.status(500).json({ success: false, error: error.message });
                }

            case 'signal':
                const { generateSignal } = await import('../src/utils/signal.js');
                result = await generateSignal(symbol);
                break;

            case 'review':
                const { generateReview } = await import('../src/utils/review.js');
                const { entry, sl, mode } = req.body; // mode = BUY/SELL
                // Check required params
                if (!entry || !mode) {
                    result = "❌ Data entry dan action (BUY/SELL) wajib diisi.";
                } else {
                    result = await generateReview(mode, symbol, entry, sl);
                }
                break;

            default:
                return res.status(400).json({ error: 'Invalid action' });
        }

        // Convert Markdown to HTML for web display if it's not already HTML
        // fetchHarga returns strings with emojis, some utils return HTML, some Markdown.
        // Ideally we treat everything as HTML or convert MD to HTML.
        // Simple heuristic: if it contains <b> or <br>, assume HTML, else Markdown.
        const isHtml = /<[a-z][\s\S]*>/i.test(result);
        // Even if it is HTML, we might want to run it through marked if it has mixed content? 
        // Actually, existing bot output is mixed.
        // Let's standardise on sending JSON with a 'html' field.

        let htmlOutput = result;
        if (!isHtml) {
            const markedFn = await loadMarked();
            htmlOutput = markedFn(result, { breaks: true });
        }
        // Force newlines to <br> if not handled by marked (e.g. plain text with \n)
        // If marked handled it, it should have inserted <br> for \n
        if (!htmlOutput.includes('<p>') && !htmlOutput.includes('<br>')) {
            htmlOutput = htmlOutput.replace(/\n/g, '<br>');
        }

        res.status(200).json({
            success: true,
            data: htmlOutput
        });

    } catch (error) {
        console.error('Web Context Error:', error);
        res.status(500).json({
            error: 'AI Overload, Cobalagi beberapa saat',
            details: error.message || error,
            hint: 'Ensure your DB tables exist and environment variables are set correctly in Vercel.'
        });
    }
};
